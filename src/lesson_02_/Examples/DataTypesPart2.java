package lesson_02_.Examples;

/**
 * Created by galina on 2/28/16.
 */
public class DataTypesPart2 {

    static class Point {
        int x, y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    private static boolean print(int x){
        System.out.println(x);
        return true;
    }


    private static boolean divide(int x, int y){
        int result = x/y;
        return true;
    }
    public static void main(String[] args) {
        /*************************************************************************
         *                                   CHAR
         *************************************************************************/
        //Значения типа char могут полноценно участвовать в числовых операциях:
        // char – единственный беззнаковый тип.
        // Инициализировать его можно как символьным, так и целочисленным литералом.
        char c1 = 10;
        char c2 = 'A';
        // латинская буква A (\u0041, код 65)
        int i12 = c1 + c2 - 'B'; //Переменная i12 получит значение 9.

        char c13 = 'A';
        System.out.println(c13);
        System.out.println(c13 + 1);
        System.out.println("c13 = " + c13);
        System.out.println('c' + '=' + c13);

        //В первом случае в метод println было передано значение типа char, поэтому отобразился символ.
        // Во втором случае был передан результат сложения, то есть число, и именно число появилось на экране.
        // Далее при сложении со строкой тип char был преобразован в текст в виде символа.
        // Наконец в последней строке произошло сложение трех чисел: 'c' (код 99), '=' (код 61) и переменной c (т.е. код 'A' - 65 ).

        /***********************************************************************
         *                            ДРОБНЫЕ ТИПЫ
         ***********************************************************************/

        /*  Название типа	Длина (байты)	Область значений
             float          |   	4      | 3.40282347e+38f ; 1.40239846e-45f
             double         |    	8      | 1.79769313486231570e+308 ; 4.94065645841246544e-324 */

        // пример вызовет ошибку компиляции
        //    float f = 1e40f; // значение слишком велико, overflow
        //    double d = 1e-350; // значение слишком мало, underflow

        /* Eсли в конце литерала стоит буква F или f, то литерал рассматривается как значение типа float.
         По умолчанию дробный литерал имеет тип double, при желании это можно подчеркнуть буквой D или d.

          * операции сравнения (возвращают булево значение):  <, <=, >, >= ,==, !=
          * числовые операции (возвращают числовое значение)
               -  унарные операции + и -
               -  арифметические операции +, -, *, /, %
               -  операции инкремента и декремента (в префиксной и постфиксной форме): ++ и --
          * оператор с условием ?:
          * оператор приведения типов
          * оператор конкатенации со строкой +    */


        double doubleV = (double)1 / 2;
        System.out.println("doubleV = " + doubleV);


        System.out.println(1e-40f / 1e10f);   // underflow для float
        System.out.println(-1e-300 / 1e100);  // underflow для double
        float f = 1e-6f;
        System.out.println("f = " + f);   //Результат f = 1.0E-6
        f += 0.002f;
        System.out.println("f = " + f);   //Результат f = 0.002001
        f += 3;
        System.out.println("f = " + f);    //Результат f = 3.002001
        f += 4000;
        System.out.println("f = " + f); //Результат f = 4003.002
        //Как видно, в последней строке был утрачен 6-й разряд после десятичной точки.


        double d = 1e-305 * Math.PI;
        System.out.println(d);            // Результат 3.141592653589793E-305
        for (int r = 0; r < 4; r++)
            System.out.println(d /= 100000);   //  Результат 3.1415926535898E-310   ; 3.141592653E-315 ; 3.142E-320 ;0.0

       /*                           ПРЕОБРАЗОВАНИЕ ТИПОВ.
         Если хотя бы один аргумент имеет тип double, то значения всех аргументов приводятся к этому типу
         и результат операции также будет иметь тип double. Вычисление будет произведено с точностью в 64 бита.
         Если же аргументов типа double нет, а хотя бы один аргумент имеет тип float, то все аргументы приводятся к float,
         вычисление производится с точностью в 32 бита и результат имеет тип float.
         Эти утверждения верны и в случае, если один из аргументов целочисленный.Если хотя бы один из аргументов
         имеет значение NaN, то и результатом операции будет NaN.   */


        System.out.println("1/2 = " + 1 / 2);  // Результат  ?
        System.out.println("1/2. = " + 1 / 2.); // Результат ?

        //  Достаточно одного дробного аргумента, чтобы результат операции также имел дробный тип.

        int x33 = 3;
        int y33 = 5;
        System.out.println(x33 / y33);        //  Результат  0
        System.out.println((double) x33 / y33);  // Результат  0.6
        System.out.println(1.0 * x33 / y33);      //  Результат 0.6
        System.out.println("3.84 = " + ((int) 3.84));     //  Результат 3
        System.out.println("-3.84 = " + ((int) -3.84));    //  Результат -3

        long l = 111111111111L;
        float f10 = l;
        l = (long) f10;
        System.out.println(l);     //  Результат 111111110656


        /****************************************************************
         *                          БУЛЕВ ТИП
         ****************************************************************/

       /* Булев тип представлен всего одним типом boolean,
        который может хранить всего два возможных значения – true и false.
         Величины именно этого типа получаются в результате операций сравнения.

         Над булевыми аргументами можно производить следующие операции:
        * операции сравнения (возвращают булево значение) : ==, !=
        * логические операции (возвращают булево значение): !, &, |, ^, &&, ||
        * оператор с условием ?:
        * оператор конкатенации со строкой +
        В операторе с условием ?: первым аргументом может быть только значение типа boolean.
        Операция конкатенации со строкой превращает булеву величину в текст "true" или "false" в зависимости от значения.

        В операторе с условием ?: первым аргументом может быть только значение типа boolean.
        Также допускается, чтобы второй и третий аргументы одновременно имели булев тип.
        Операция конкатенации со строкой превращает булеву величину в текст "true" или "false" в зависимости от значения.
        Только булевы выражения допускаются для управления потоком вычислений, например, в качестве критерия условного перехода if.
        Никакое число не может быть интерпретировано как булево выражение.
        Если предполагается, что ненулевое значение эквивалентно истине (по правилам языка С), то необходимо записать x!=0.
        Ссылочные величины можно преобразовывать в boolean выражением ref!=null.

        Логические операторы :
        Первый вариант операторов ( &, | ) всегда вычисляет оба операнда,
        второй же – ( &&, || ) не будет продолжать вычисления, если значение выражения уже очевидно.
        */
       // Пример1:
        int x=1;
        boolean bb1 =  (x>0) | print(x);  // в таком выражении произойдет вызов метода print
        boolean bb2 =  (x>0) || print(x); // а в этом - нет

        // Пример2:
        int y=0;
    //    boolean bb3 =  (y!=0) & divide(x, y);  // Exception in thread "main" java.lang.ArithmeticException: / by zero
        boolean bb4 =  (y != 0) && divide(x, y); // а в этом - нет

      //  Логический оператор отрицания "не" записывается как !. Этот оператор меняет булевское значение на противоположное.

        int one=1;
        System.out.println(one > 0);    // выражение истинно
        System.out.println(!(one > 0)); // выражение ложно

       /* Оператор с условием ?: состоит из трех частей – условия и двух выражений.
        Сначала вычисляется условие (булевское выражение), а на основании результата значение всего оператора
         определяется первым выражением в случае получения истины и вторым – если условие ложно.
         Например, так можно вычислить модуль числа k:
         */
     int k=-200;
     int mod =   k>0 ? k : -k;
        System.out.println(mod);

    }

}