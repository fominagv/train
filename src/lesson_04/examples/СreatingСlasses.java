package lesson_04.examples;


import lesson_04.activities.Human;
import java.awt.Point;

import java.io.Serializable;

/**
 * Created by galina on 3/13/16.
 */
public class СreatingСlasses {
    Human h = new Human();
    // Что произойдет если в классе Human поменять тип age на double?
    int i = h.age;


    /**
     * *************  Заголовок класса *******************
     */
  /*Вначале указываются модификаторы класса. При объявлении типов(классы и интерфейсы) допустимыми являются public, либо его отсутствие – доступ по умолчанию(тип доступен только внутри того пакета, где он объявлен).
    Класс может быть объявлен как final. В этом случае не допускается создание наследников такого класса.
    Класс String и классы-обертки, например, представляют собой final -классы.
    После списка модификаторов указывается ключевое слово class, а затем имя класса – корректный Java-идентификатор.
    Указанный идентификатор становится простым именем класса.
    Далее заголовок может содержать ключевое слово extends, после которого должно быть указано имя (простое или составное) доступного не- final класса.
    В этом случае объявляемый класс наследуется от указанного класса. Если выражение extends не применяется, то класс наследуется напрямую от Object.
    Выражение extends Object допускается и игнорируется.*/
    class Parent {
    } // = class Parent extends Object {}

    final class LastChild extends Parent {
    }

    // class WrongChild extends LastChild {} // ошибка!!

    /**********  Наследование классов ************
     Если в объявлении класса A указано выражение extends B, то класс A называют прямым наследником класса B.
     Класс A считается наследником класса B, если:
     - A является прямым наследником B ;
     - существует класс C, который является наследником B, а A является наследником C (это правило применяется рекурсивно).
     Таким образом можно проследить цепочки наследования на несколько уровней вверх.
     Если компилятор обнаруживает, что класс является своим наследником, возникает ошибка компиляции:*/
    // пример вызовет ошибку компиляции
   /* class A extends B {}
    class B extends C {}
    class C extends A {}*/ // ошибка! Класс А стал своим наследником

    /************* Реализация интерфейсов **************/
    //Далее в заголовке может быть указано ключевое слово implements, за которым должно следовать перечисление через запятую имен (простых или составных, повторения запрещены) доступных интерфейсов:
    // public final class String implements Serializable, Comparable {}
    // Класс может реализовывать любое количество интерфейсов.


    /**
     * ************** TЕЛО КЛАССА *********************
     */
 /* Тело класса может содержать объявление элементов (members) класса:
    - полей;
    - внутренних типов (классов и интерфейсов);

    и остальных допустимых конструкций:
    - конструкторов;
    - инициализаторов
    - статических инициализаторов.

Элементы класса имеют имена и передаются по наследству, не-элементы – нет. Для элементов простые имена указываются при объявлении, составные формируются из имени класса, или имени переменной объектного типа, и простого имени элемента.
 Областью видимости элементов является все объявление тела класса. Допускается применение любого из всех четырех модификаторов доступа.

Не-элементы не обладают именами, а потому не могут быть вызваны явно. Их вызывает сама виртуальная машина.
Например, конструктор вызывается при создании объекта.

Элементами класса являются элементы, описанные в объявлении тела класса и переданные по наследству от класса-родителя
и всех реализуемых интерфейсов при условии достаточного уровня доступа.
Если класс содержит элементы с доступом по умолчанию, то его наследники из разных пакетов будут обладать разным набором элементов.
Классы из того же пакета могут пользоваться полным набором элементов, а из других пакетов – только protected и public.
private -элементы по наследству не передаются.

Поля и методы могут иметь одинаковые имена, поскольку обращение к полям всегда записывается без скобок, а к методам – всегда со скобками.*/

    static class Point {
        int getX() {
            return x;
        }

        int y = getX();
        int x = 3;
    }

    public static void main(String s[]) {
        Point p = new Point();
        System.out.println(p.x + ", " + p.y);  //Какой будет результат?
    }

    /*Все поля класса имеют значение по умолчанию:
    для числовых полей примитивных типов – 0 ;
    для булевского типа – false ;
    для ссылочных – null. */

    /***************************************************
     *           Объявление методов
     ***************************************************/
    /*Объявление метода состоит из заголовка и тела метода.
     Заголовок состоит из:
        - модификаторов (доступа в том числе);
        Для методов доступен любой из трех возможных модификаторов доступа.
        Также допускается использование доступа по умолчанию. Кроме того, существует модификатор final, который говорит о том,
        что такой метод нельзя переопределять в наследниках. Можно считать, что все методы final -класса,
        а также все private - методы любого класса, являются final.
        - типа возвращаемого значения или ключевого слова void ;
        - имени метода ;
        - списка аргументов в круглых скобках (аргументов может не быть);
        Если аргументы отсутствуют, указываются пустые круглые скобки. Одноименные параметры запрещены.
        Создание локальных переменных в методе с именами, совпадающими с именами параметров, запрещено.
        Для каждого аргумента можно ввести ключевое слово final перед указанием его типа.
        В этом случае такой параметр не может менять своего значения в теле метода
        (то есть участвовать в операции присвоения в качестве левого операнда).
        - специального throws -выражения.
     */
    public void process(int x, final double y) {
        x = x * x;
       //  y=Math.sin(x);   //так писать нельзя, т.к. y - final!
    }

    /* Сигнатура определяется именем метода и его аргументами (количеством, типом, порядком следования).
     Если для полей запрещается совпадение имен, то для методов в классе запрещено создание двух методов с одинаковыми сигнатурами.*/
    class Point1 {
        void get() {}

        void get(int x) {}

        void get(int x, double y) {}

        void get(double x, int y) {}
    }

        //Следующие пары методов в одном классе друг с другом несовместимы:
     /*   class Point2 {
     // методы отличаются типом возвращаемого значения, которое, однако, не входит в определение сигнатуры
        void get() {}
        int get() {}

     // пара методов различается именем аргументов, которые также не входят в определение сигнатуры
        void get(int x) {}
        void get(int y) {}

       //пара различается лишь модификаторами доступа, что также недопустимо.
        public int get() {}
        private int get() {}

    } */

    //Если в заголовке метода указан тип возвращаемого значения, а не void,
    //то в теле метода обязательно должно встречаться return -выражение.
    // При этом компилятор проводит анализ структуры метода, чтобы гарантировать,
    // что при любых операторах ветвления возвращаемое значение будет сгенерировано.
    // Например, следующий пример является некорректным:

    // пример вызовет ошибку компиляции
/*    public int get() {
        if (condition) {
            return 5;
        }
    }*/


  //  В методе без возвращаемого значения (указано void ) также можно использовать выражение return без каких-либо аргументов.
  // Его можно указать в любом месте метода и в этой точке выполнение метода будет завершено:
    public void calculate(int x, int y) {
        if (x<=0 || y<=0) {
            return;   // некорректные входные
            // значения, выход из метода
        }
       // ...   // основные вычисления
    }

    /*********************************************************
     *               Объявление конструкторов
     *********************************************************/
   //Заголовок состоит, во-первых, из модификаторов доступа (никакие другие модификаторы недопустимы).
   //Во-вторых, указывается имя класса

    public class Man {
        private int age;

        protected Man(int a) {
            age=a;
        }

        public Man(String name, Human mother,
                     Human father) {
            age=0;
        }
    }
    /* Далее следует перечисление входных аргументов по тем же правилам, что и для методов.
     Завершает заголовок конструктора throws-выражение (в примере не использовано, см. лекцию 10 "Исключения").
     Оно имеет особую важность для конструкторов, поскольку сгенерировать ошибку – это для конструктора единственный способ не создавать объект.
     Если конструктор выполнился без ошибок, то объект гарантированно создается.
     Сигнатура конструктора определяется только набором входных параметров по тем же правилам,
     что и для методов. Аналогично, в одном классе допускается любое количество конструкторов, если у них различные сигнатуры.
     Обязательное правило – первой строкой в конструкторе должно быть обращение к родительскому классу,
     которое записывается с помощью ключевого слова super.
     */

     class Parent1 {
        private int x, y;

        public Parent1() {
            x=y=0;
        }

        public Parent1(int newx, int newy) {
            x=newx;
            y=newy;
        }
    }

     class Child1 extends Parent1 {
        public Child1() {
            super();
        }

        public Child1(int newx, int newy) {
            super(newx, newy);
        }
    }
}