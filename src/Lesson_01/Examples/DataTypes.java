package Lesson_01.Examples;

/**
 * Created by galina on 2/28/16.
 */
public class DataTypes {

    static class Point {
        int x, y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public static void main(String[] args) {
        //Все типы данных разделяются на две группы.
        // Первую составляют 8 простых, или примитивных (о
        // Они подразделяются на три подгруппы:
        // целочисленные : byte, short, int, long, char
        //дробные: float, double
        //булевые: boolean
        // Вторую группу составляют объектные, или ссылочные (от английского reference), типы данных.
        // Это все классы, интерфейсы и массивы.

        final double pi = 3.1415;
        int a = 5;   // объявляем первую переменную и
        // инициализируем ее
        int b = a;   // объявляем вторую переменную и
        // приравниваем ее к первой
        a = 3;       // меняем значение первой
        System.out.println("b = " + b);  // проверяем значение второй


// Переменные простого типа хранят непосредственно свои значения
// и при приравнивании двух переменных происходит копирование данного значения.
        byte byteV = 3;
        int intV = byteV;
        System.out.println("intV = " + intV);
//Объектные переменные после приравнивания остаются "связанными" друг с другом,
// изменения одной сказываются на другой.
        Point p1 = new Point(3, 5);
        Point p2 = p1;
        p1.x = 7;
        System.out.println("p2.x = " + p2.x);

        Point p3 = new Point(3, 5);
        Point p4 = p3;
        p3 = new Point(7, 9);
        System.out.println("p4.x = " + p4.x);

// переполнение типов
        int x = 300000;
        System.out.println("x * x = " + x * x);


        int i = 300000;
        System.out.println("i * i = " + i * i);   // умножение с точностью 32 бита
        long m = i;
        System.out.println("m * m = " + m * m);   // умножение с точностью 64 бита
        // System.out.println("1 / (m - i)"+1 / (m - i)); // попробуем получить разность
        // значений int и long

        double doubleV = (double)1 / 2;
        System.out.println("doubleV = " + doubleV);

        System.out.println(1000 * 60 * 60 * 24 * 7);
        // вычисление для недели
        System.out.println(1000 * 60 * 60 * 24 * 30);
        // вычисление для месяца

        System.out.println(1000L * 60 * 60 * 24 * 30);
        // вычисление для месяца


        // пример вызовет ошибку компиляции
        int x1 = 1;
         byte b1 = (byte)x;

        // пример вызовет ошибку компиляции
        byte b2 = 1;
        byte c2 = (byte)(b2+1);

        // пример вызовет ошибку компиляции
        int x3 = 2;
        long y3 = 3;
        long z3 = x3+y3;


        // Итак, все числовые операторы возвращают результат типа int или long. Однако существует два исключения.
        // Первое из них – операторы инкрементации и декрементации.
        // Их действие заключается в прибавлении или вычитании единицы из значения переменной,
        // после чего результат сохраняется в этой переменной и значение всей операции равно значению переменной
        // (до или после изменения, в зависимости от того, является оператор префиксным или постфиксным).
        // А значит, и тип значения совпадает с типом переменной.
        // (На самом деле, вычисления все равно производятся с точностью минимум 32 бита,
        // однако при присвоении переменной результата его тип понижается.)

        byte x7 = 5;
        System.out.println("x7++ = " + x7++);  // на момент начала исполнения x равен 5
        System.out.println("x7-- = " + x7--); //на момент начала исполнения x равен 6
        System.out.println("++x7 = " + (++x7)); // на момент начала исполнения x равен 5
        System.out.println("--x7 = " + (--x7));  // на момент начала исполнения x равен 6


//Этот пример иллюстрирует вопросы преобразования типов при вычислениях и случаи переполнения.

        byte x9 = -128;
        System.out.println("-x9 = " + (-x9));

        byte y9 = 127;
        System.out.println("++y9 = " + (++y9));

        // Вторым исключением является оператор с условием ?:.
        // Если второй и третий операнды имеют одинаковый тип, то и результат операции будет такого же типа.

        byte x10 = 2;
        byte y10 = 3;
        byte z = (x10 > y10) ? x10 : y10;
        // верно, x10 и y10 одинакового типа
        //  byte abs=(x10>0) ? x10 : -x10;  // неверно!

        // Последняя строка неверна, так как третий аргумент содержит числовую операцию,
        // стало быть, его тип int, а значит, и тип всей операции будет int, и присвоение некорректно.
        // Даже если второй аргумент имеет тип byte, а третий – short, значение будет типа int.

        // Наконец, рассмотрим оператор конкатенации со строкой.
        // Оператор + может принимать в качестве аргумента строковые величины.
        // Если одним из аргументов является строка, а вторым – целое число,
        // то число будет преобразовано в текст и строки объединятся.

        int x11 = 1;
        System.out.println("x11 = " + x11);

        System.out.println(1 + 2 + "text");
        System.out.println("text" + 1 + 2);

        // Pассмотрим работу с типом char. Значения этого типа могут полноценно участвовать в числовых операциях:

        char c1 = 10;
      //  char c2 = 'A';
        // латинская буква A (\u0041, код 65)
      //  int i12 = c1 + c2 - 'B'; //Переменная i12 получит значение 9.

        char c13 = 'A';
        System.out.println(c13);
        System.out.println(c13 + 1);
        System.out.println("c13 = " + c13);
        System.out.println('c' + '=' + c13);

        //В первом случае в метод println было передано значение типа char, поэтому отобразился символ.
        // Во втором случае был передан результат сложения, то есть число, и именно число появилось на экране.
        // Далее при сложении со строкой тип char был преобразован в текст в виде символа.
        // Наконец в последней строке произошло сложение трех чисел: 'c' (код 99), '=' (код 61) и переменной c (т.е. код 'A' - 65 ).

        //  --------------------------------------------------------------

        //  Название типа	Длина (байты)	Область значений
        //   float          |   	4         | 3.40282347e+38f ; 1.40239846e-45f
        //   double         |    	8         | 1.79769313486231570e+308 ; 4.94065645841246544e-324

        // пример вызовет ошибку компиляции
        //    float f = 1e40f; // значение слишком велико, overflow
        //    double d = 1e-350; // значение слишком мало, underflow

        //Eсли в конце литерала стоит буква F или f, то литерал рассматривается как значение типа float.
        // По умолчанию дробный литерал имеет тип double, при желании это можно подчеркнуть буквой D или d.

        //  * операции сравнения (возвращают булево значение):  <, <=, >, >= ,==, !=
        //  * числовые операции (возвращают числовое значение)
        // -  унарные операции + и -
        // -  арифметические операции +, -, *, /, %
        // -  операции инкремента и декремента (в префиксной и постфиксной форме): ++ и --
        //  * оператор с условием ?:
        //  * оператор приведения типов
        //  * оператор конкатенации со строкой +

        System.out.println(1e-40f / 1e10f);   // underflow для float
        System.out.println(-1e-300 / 1e100);  // underflow для double
        float f = 1e-6f;
        System.out.println("f = " + f);   //Результат f = 1.0E-6
        f += 0.002f;
        System.out.println("f = " + f);   //Результат f = 0.002001
        f += 3;
        System.out.println("f = " + f);    //Результат f = 3.002001
        f += 4000;
        System.out.println("f = " + f); //Результат f = 4003.002
        //Как видно, в последней строке был утрачен 6-й разряд после десятичной точки.


        double d = 1e-305 * Math.PI;
        System.out.println(d);            // Результат 3.141592653589793E-305
        for (int r = 0; r < 4; r++)
            System.out.println(d /= 100000);   //  Результат 3.1415926535898E-310   ; 3.141592653E-315 ; 3.142E-320 ;0.0

        // ПРЕОБРАЗОВАНИЕ ТИПОВ.
        // Если хотя бы один аргумент имеет тип double, то значения всех аргументов приводятся к этому типу
        // и результат операции также будет иметь тип double. Вычисление будет произведено с точностью в 64 бита.
        // Если же аргументов типа double нет, а хотя бы один аргумент имеет тип float, то все аргументы приводятся к float,
        // вычисление производится с точностью в 32 бита и результат имеет тип float.
        // Эти утверждения верны и в случае, если один из аргументов целочисленный.Если хотя бы один из аргументов
        // имеет значение NaN, то и результатом операции будет NaN.


        System.out.println("1/2 = " + 1 / 2);  // Результат  ?
        System.out.println("1/2. = " + 1 / 2.); // Результат ?

        //  Достаточно одного дробного аргумента, чтобы результат операции также имел дробный тип.

        int x33 = 3;
        int y33 = 5;
        System.out.println(x33 / y33);        //  Результат  ?
        System.out.println((double) x33 / y33);  // Результат  ?
        System.out.println(1.0 * x33 / y33);      //  Результат ?
        System.out.println("3.84 = " + ((int) 3.84));     //  Результат ?
        System.out.println("-3.84 = " + ((int) -3.84));    //  Результат ?

        long l = 111111111111L;
        float f10 = l;
        l = (long) f10;
        System.out.println(l);     //  Результат ?


        // BOOLEAN
        // Над булевыми аргументами можно производить следующие операции:
        // * операции сравнения (возвращают булево значение) : ==, !=
        // * логические операции (возвращают булево значение): !, &, |, ^, &&, ||
        //* оператор с условием ?:
        //* оператор конкатенации со строкой +
        //В операторе с условием ?: первым аргументом может быть только значение типа boolean.
        //Операция конкатенации со строкой превращает булеву величину в текст "true" или "false" в зависимости от значения.

    }
}