package lesson_05.examples;

/**
 * Created by galina on 3/22/16.
 */

/***********************   Абстрактные классы  **************************
Абстрактным называется класс, на основе которого не могут создаваться объекты.
При этом наследники класса могут быть не абстрактными, на их основе объекты создавать, соответсвенно, можно.

Для того, чтобы превратить класс в абстрактный перед его именем надо указать модификатор abstract.

Рассмотрим пример абстрактного класса A: */
abstract class A {
    int p1;
    A() {
        p1 = 1;
    }
    void print() {
        System.out.println(p1);
    }
}
class B extends A {
}

public class AbstractClasses {

public static void main(String[] args) {
    A ob1;
    /*Java разрешит описать конструкторы в классе A, но не разрешит ими воспользоваться
     (потому что запрещено создавать объекты абстрактного класса).
    Обратите внимание на то, что объявление переменной ob1 как ссылки, на объект класса A тоже не запрещается */

    // ошибка: ob1 = new A();

/*  Зачем же может потребоваться ссылка ob1, какой объект с ней удастся связать?
    Ну, например, объект класса-потомка B. Дело в том, что класс A, как родитель, является более универсальным, чем потомок B.
    Это значит, что любой объект класса потомка может быть явно или даже автоматически приведён к классу родителю. */
    B ob2 = new B(); // будет вызван конструктов по умолчанию из A
    ob1 = (A) ob2; // явное приведение или
  //  ob1 = ob2; // автоматическое приведение
  // Как для встроенных типов, так и для классов автоматическое приведение всегда возможно,
 //   когда переменную или объект мы пытаемся привести к более универсальному типу
    ob2.print();


/*******************  Абстрактные методы  *********************

 Абстрактным называется метод, который не имеет реализации в данном классе.
 После круглых скобок, где перечислены его аргументы, ставится не открывающая фигурная скобка, чтобы начать блок описания метода, а точка с запятой.
 То есть описание у абстрактноно метода отсутствует. Перед именем метода указывается при этом модификатор abstract.

 Какой смысл в создании метода без реализации? Ведь его нельзя будет использовать.
 Для объектов того класса, где метод описан – конечно же использовать нельзя, но вот если унаследовать класс и в потомках переопределить метод,
 задав там его описание, то для объектов классов потомков метод можно будет вызывать (и работать будут описанные в классах потомках реализации).

 Чтобы исключить возможность использования абстрактного метода, в Java введено следующее требование: класс имеющий хоть один абстрактный метод обязан быть абстрактным классом.
 Когда же уместно использовать абстрактные методы и классы?
 Сначала рассмотрим пример иерархии классов домашних животных, где нет ни абстрактных классов, ни абстрактных методов.
 */


    Pet zorka = new Pet();
    zorka.food();
    Fish nemo = new Fish();
    nemo.voice();

    /*Поскольку нет какого-то общего звука, который издавали бы все домашние животные, то мы в классе Pet
не стали задавать какую-то реализауию методу voice(), внутри метода не делается совсем ничего,
 но тем не менее у него есть тело, обособленное блоком из фигурных скобок.
 Метод voice() хороший претендент на то, чтобы стать абстрактным.*/

}
}

class Pet {
    String name;
    int age;
    boolean hungry;
    void voice() {
    }
    void food() {
        hungry = false;
    }
}
class Snake extends Pet {
    double length;
    void voice() {
        System.out.println("Шшш-ш-ш");
    }
}
class Dog extends Pet {
    void voice() {
        System.out.println("Гав-гав");
    }
}
class PatrolDog extends Dog {
    void voice() {
        System.out.println("Ррр-р-р");
    }
}
class Cat extends Pet {
    void voice() {
        System.out.println("Мяу-мяу");
    }
}
class Fish extends Pet {
}
