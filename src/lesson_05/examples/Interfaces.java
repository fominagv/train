package lesson_05.examples;

/**
 * Created by galina on 3/22/16.
 */

/*
Интерфейс это консутрукция языка программирования Java, в рамках которой могут описываться только абстрактные публичные (abstract public) методы
и статические константы (final static). То есть также, как и на основе абстрактных классов, на основе интерфейсов нельзя порождать объекты.
Один интерфейс может быть наследником другого интерфейса.
Классы могут реализовывать интерфейсы (т. е. получать от интерфейса список методов и описывать реализацю каждого из них),
притом, что особенно важно, один класс может реализовывать сразу несколько интерфейсов.
Перед описанием интерфейса указывается ключевое слово interface.
Когда класс реализуемт интерфейс, то после его имени указывается ключевое слово implements и далее через запятую перечисляются имена тех интерфейсов,
методы которых будут полностью описаны в классе.

Пример:  */

interface Instruments {
    final static String key = "Скирпичный";
    public void play();
}
class Drum implements Instruments {
    public void play() {
        System.out.println("бум бац бац бум бац бац");
    }
}
class Guitar implements Instruments {
    public void play() {
        System.out.println("до ми соль до ре до");
    }
}
/*Поскольку все свойства интерфейса должны быть константными и статическими, а все методы общедоступными,
 то соответсвующие модификаторы перед свойствами и методами разрешается не указывать.
  То есть интерфейс можно было описать так: */

interface Instruments1 {
    static public String key = "До мажор";
    void play();
}
//Но когда метод play() будет описываться в реализующем интерфейс классе, перед ним всё равно необходимо будет явно указать модификатор public.

/********** Множественное наследование интерфейсов *********

Java не поддерживает множественное наследование классов. Это объясняется тем, что такое наследование порождает некоторые проблемы.
Вместо множественного наследования классов в Java введено множественное наследование интерфейсов,
 которое часично решает проблемы (но, как будет показано в примере далее, к сожалению, не все).

Рассмотрим пример, где реализовано два интерфейса с методами доступными для грузового и для легкового транспорта.
 Класс Pickup (пикап) должен обладать как возможностью перевозки грузов, так и пассажиров,
 поэтому он реализует сразу оба интерфейса: */

interface PassangersAuto {
    void transportPassangers();
}
interface CargoAuto {
    void transportCargo();
}
class Truck implements CargoAuto {
    final static int a = 1;
    public void transportCargo() {
        System.out.println("Везу груз");
    }
}
class Sedan implements PassangersAuto {
    public void transportPassangers() {
        System.out.println("Везу пассажиров");
    }
}
class Pickup implements CargoAuto, PassangersAuto {
    public void transportCargo() {
        System.out.println("Везу груз");
    }
    public void transportPassangers() {
        System.out.println("Везу пассажиров");
    }
}
/*Часто всю открытую часть класса (т. е. общедоступные методы) предопределяю как раз в интерфейсе.
 Тогда взглянув на один лишь интерфейс можно поять какие же методы должны использоваться для взаимодействия с объектами данного класса.
 То есть интерфейсы вполне соответствуют принципам инкапсуляцуии. Как, впрочем, и принципу полиморфизма.
  Ведь в нескольких классах метод некоторого интерфейса может быть реализован по-разному, хотя и с одним и тем же именем.

Но интерфейсы, как говорилось выше, не являются совершенным инструментом лишенным всяких недостатков.
 Рассмотрим пример, когда у нас имеются два интерфейса,
  в каждом из которых есть свойства с одинаковыми именами (но, возможно, разными значениями) и методы с одинаковыми именами.

Унаследовав класс от пары этих интерфейсов мы не сможем обращаться к свойству его объектов напрямую,
 без указания того, какой из двух интерфейсов мы имели в виду. Это ограничение существует потому,
 что в интерфейсах свойствам может даваться разное начальное значение и, соответсвенно,
  программа не сможет определить какое же значение выбрать.

Также к свойству можно обратиться как к статическому свойству одного из интерфейсов (разумеется, это можно делать и если у свойств были бы разные имена).
Проблема исчезнет, если перед обращением к свойству мы приведём объект к одному из родительских интерфейсов (напомним, что любой объект можно явно привести к классу или интерфейса его родителя прямого или транзитивного).
К сожалению, создать отдельные реализации для двух одноимённых методов из разных интерфейсов в классе наследнике не получится (чтобы потом ими можно было пользоваться через то же приведение объектов к нужному интерфейсу).
 Если класс реализует несколько интерфейсов, в которых есть одноимённые методы, то в нём может задаваться лишь одна общая для всех реализация этих методов
  (и это уже ограничивает полиморфизм при множественном наследовании через интерфейсы в Java).

Итак, код примера: */

interface Interface1 {
    int someField = 100;
    String someMethod();
}
interface Interface2 {
    int someField = 200;
    String someMethod();
}
class SomeClass implements Interface1, Interface2 {
    public String someMethod() {
        return "It Works";
    }
}
public class Interfaces {
    public static void main(String[] args) {
        SomeClass a = new SomeClass();
        System.out.println( a.someMethod() ); // It works
     //   System.out.println( a.someField ); // ошибка
        System.out.println( ( (Interface1) a).someField ); // 100
        System.out.println( Interface1.someField ); // 100
    }
}


